<!DOCTYPE html><html><head lang="en"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>BabylonJS Guide</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" href="/css/libs/slideout.css"><link rel="stylesheet" href="/css/libs/highlight/github.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.3/css/perfect-scrollbar.min.css"><link rel="stylesheet" href="/css/main.css"></head><body><nav id="menu"></nav><nav class="nav-main"><!-- Hamburger menu : displayed only in small screens--><i id="mobilemenu" class="fa fa-bars"></i><!-- this button only shows on mobile version of a "class" page--><div class="banner"><div class="menu"><div id="home" class="do-not-hover"><a href="/">Babylon.js | GUIDE</a></div><div id="begin" class="item"><a href="/begins.html">Begin Here</a></div><div id="basic" class="item"><a href="/basics.html">Basics</a></div><div id="intermediate" class="item"><a href="/intermediate.html">Intermediate</a></div><div id="advanced" class="item"><a href="/advanced.html">Advanced</a></div></div></div></nav><div id="wrapper"><div class="statics-banner"><h1>advanced</h1></div><div class="horizontal-separator"></div><div class="static-content"><h1>Creating Custom Meshes</h1><br><div class="contentTable"><div class="tocHeader"><span class="tocTitle"><i class="tocIcon fa fa-book"></i>Table of contents</span><span class="tocToggle"><i class="fa fa-arrow-up"></i></span></div><div class="tocContent"><ul>
<li><a href="#meshes-from-scratch">Meshes from Scratch</a><ul>
<li><a href="#positions-and-indices">Positions and Indices</a></li>
<li><a href="#normals">Normals</a><ul>
<li><a href="#calculating">Calculating</a></li>
<li><a href="#direction">Direction</a></li>
<li><a href="#lighting">Lighting</a></li>
<li><a href="#visibility">Visibility</a></li>
</ul>
</li>
<li><a href="#color">Color</a><ul>
<li><a href="#notes-on-the-playground">Notes on the Playground</a></li>
</ul>
</li>
<li><a href="#texture">Texture</a><ul>
<li><a href="#notes-on-playground">Notes on Playground</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
</div></div><div id="staticContent"><h1><a name="meshes-from-scratch" class="anchor" href="#meshes-from-scratch"></a>Meshes from Scratch</h1><p>Each and every shape in BabylonJS is built from a mesh of triangles or facets as shown below.</p>
<p><img src="/img/custom1.jpg" alt="Custom Mesh"></p>
<p>Every facet is made up of three vertices each of which is assigned data that not only affects the position of the facet but also 
its colour, texture and how it is lit. The complex process of applying a shader to turn this data into a viewable mesh 
is all carried out by BabylonJS.</p>
<h2><a name="positions-and-indices" class="anchor" href="#positions-and-indices"></a>Positions and Indices</h2><p>Creating a mesh with two facets one with vertices at (-5, 2, -3), (-7, -2, -3), (-3, -2, -3) and the other with vertices at (5, 2, 3), (7, -2, 3), (3, -2, 3) 
requires each vertex to have a unique index. Indices should start at 0 and increase consecutively.</p>
<table>
<thead>
<tr>
<th>index</th>
<th>position</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(-5, 2, -3)</td>
</tr>
<tr>
<td>1</td>
<td>(-7, -2, -3)</td>
</tr>
<tr>
<td>2</td>
<td>(-3, -2, -3)</td>
</tr>
<tr>
<td>3</td>
<td>(5, 2, 3)</td>
</tr>
<tr>
<td>4</td>
<td>(7, -2, 3)</td>
</tr>
<tr>
<td>5</td>
<td>(3, -2, 3)</td>
</tr>
</tbody>
</table>
<p>Note when assigning indices it does not need the positions to be listed in any particular order.</p>
<p>The positions data is stored in an array of numbers. The vertex with index 0 is placed with the x coordinate in array[0], the y at array[1] and z at array[2]. 
In general the vertex with index i is placed with the x coordinate at array[3i], y at array[3i + 1] and z at array[3i +2].</p>
<p>Indices forming a facet are placed together in triples, in the above example (0, 1, 2) and (3, 4, 5).
The indices data is also stored in an array of numbers with each triple being kept together.</p>
<p>In the above example the positions array is [-5, 2, -3, -7, -2, -3, -3, -2, -3, 5, 2, 3, 7, -2, 3, 3, -2, 3] and 
an indices array is [0, 1, 2, 3, 4, 5]</p>
<pre><code class="lang-javascript">var customMesh = new BABYLON.Mesh(&quot;custom&quot;, scene);

var positions = [-5, 2, -3, -7, -2, -3, -3, -2, -3, 5, 2, 3, 7, -2, 3, 3, -2, 3];
var indices = [0, 1, 2, 3, 4, 5];

var vertexData = new BABYLON.VertexData();

vertexData.positions = positions;
vertexData.indices = indices;    

vertexData.applyToMesh(customMesh);
</code></pre>
<p><a href="http://www.babylonjs-playground.com/#VKBJN#2">Playground Example Showing Custom Mesh with Positions and Indices</a> - <i class="fa fa-eye" onclick="createIframe('VKBJN#2', this)"></i><br/><div class="iframeContainer"></div><br/></p>
<h2><a name="normals" class="anchor" href="#normals"></a>Normals</h2><p>Usually a normal to a plane is a vector that is at right angles to a plane and for the this example this is true. 
BabylonJS will calculate normals for a facet and for free standing facets not sharing any vertices with another facet 
the normals will be mathematical normals. For more on how normals affect lighting see <a href="/advanced/Normals.html">Normals</a>.</p>
<h3><a name="calculating" class="anchor" href="#calculating"></a>Calculating</h3><p>Normals are calculated on the vertexData object using the ComputeNormal method which takes arrays for positions, indices and normals as parameters.</p>
<p>Additions to code</p>
<pre><code class="lang-javascript">var customMesh = new BABYLON.Mesh(&quot;custom&quot;, scene);

var positions = [-5, 2, -3, -7, -2, -3, -3, -2, -3, 5, 2, 3, 7, -2, 3, 3, -2, 3];
var indices = [0, 1, 2, 3, 4, 5];    

//Empty array to contain calculated values or normals added
var normals = [];

//Calculations of normals added
BABYLON.VertexData.ComputeNormals(positions, indices, normals);

var vertexData = new BABYLON.VertexData();

vertexData.positions = positions;
vertexData.indices = indices;
vertexData.normals = normals; //Assignment of normal to vertexData added

vertexData.applyToMesh(customMesh);
</code></pre>
<p>give the array normals = [ 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1]</p>
<p>Normals are stored in an array of numbers such that index i refers to the vector (normals[3i], normals[3i + 1], normals[3i + 2]) 
and so </p>
<table>
<thead>
<tr>
<th>index</th>
<th>normal</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(0, 0, -1)</td>
</tr>
<tr>
<td>1</td>
<td>(0, 0, -1)</td>
</tr>
<tr>
<td>2</td>
<td>(0, 0, -1)</td>
</tr>
<tr>
<td>3</td>
<td>(0, 0, 1)</td>
</tr>
<tr>
<td>4</td>
<td>(0, 0, 1)</td>
</tr>
<tr>
<td>5</td>
<td>(0, 0, 1)</td>
</tr>
</tbody>
</table>
<h3><a name="direction" class="anchor" href="#direction"></a>Direction</h3><p>Clearly the normals for each facet are pointing in the opposite directions, they all point away from the origin. </p>
<p><img src="/img/normals1.jpg" alt="Normal Direction"></p>
<p>Looking from the origin towards facet 3, 4, 5 then the order in the indices array 3, 4, 5 around the facet is clockwise.
Looking from the origin towards facet 0, 1, 2 then the order in the indices array 0, 1, 2 around the facet is also clockwise.</p>
<p><a href="http://www.babylonjs-playground.com/#VKBJN#6">Playground Example Showing Custom Mesh with Normals</a> - <i class="fa fa-eye" onclick="createIframe('VKBJN#6', this)"></i><br/><div class="iframeContainer"></div><br/></p>
<p>Reversing the order of one or both sets of facet indices in the playground will show how the normals change direction.</p>
<h3><a name="lighting" class="anchor" href="#lighting"></a>Lighting</h3><p>The closest facet to the camera in now coloured white and the farthest from the camera is black. 
This is because the addition of the normals affects the use of a light on the facet.</p>
<p>The light in the scene is travelling in the direction of the positive z axis. </p>
<pre><code class="lang-javascript">var light = new BABYLON.DirectionalLight(&quot;direct&quot;, new BABYLON.Vector3(0, 0, 1), scene);
</code></pre>
<p>White light travelling in the opposite direction to that of the normal is reflected back and the facet is seen as white, while white light travelling in the same direction as 
the normal is absorbed and the facet is seen as black.</p>
<h3><a name="visibility" class="anchor" href="#visibility"></a>Visibility</h3><p>Removing the wireframe effect then:</p>
<ol>
<li>Camera looking in positive z direction</li>
</ol>
<p><img src="/img/normals3.jpg" alt="Positive Z Direction"></p>
<p>Black facet cannot be seen.</p>
<ol>
<li>Camera looking in negative z direction</li>
</ol>
<p><img src="/img/normals4.jpg" alt="Negative Z Direction"></p>
<p>White facet not seen.</p>
<p>Why is this? There are two faces to each facet; the face that the normal is pointing away from is the front face, the other is the backface. 
By default BabylonJS does not render the back face. As many meshes will involve drawing solids then the back face of a facet will not be seen. 
To draw the back face of a mesh turn backFaceCulling to false for the material being applied to the mesh.</p>
<pre><code class="lang-javascript">mat.backFaceCulling = false;
</code></pre>
<p><img src="/img/normals5.jpg" alt="Both Facets"></p>
<p>Comment line 41 out in the following to see back face culling happening.</p>
<p><a href="http://www.babylonjs-playground.com/#VKBJN#7">Playground Example Both Facets</a> - <i class="fa fa-eye" onclick="createIframe('VKBJN#7', this)"></i><br/><div class="iframeContainer"></div><br/></p>
<h2><a name="color" class="anchor" href="#color"></a>Color</h2><p>The simplest way to assign a color to the custom mesh is by applying a standard material to the mesh and let BabylonJS do all the work. However 
color can be set for a facet within the vertex data. For information on how the arrangement of facets used in constructing a mesh can affect how colors are displayed see <a href="/advanced/Facets.html">Applying Materials to Facets</a>.</p>
<p>Colors for each vertex are placed in an array as groups of four in the order red, green, blue and alpha for transparency. For the facet 0, 1, 2 to be colored red and the facet 3, 4, 5 to be colored green each vertex 
on each facet is given the same color.</p>
<table>
<thead>
<tr>
<th>index</th>
<th>color</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(1, 0, 0, 1)</td>
</tr>
<tr>
<td>1</td>
<td>(1, 0, 0, 1)</td>
</tr>
<tr>
<td>2</td>
<td>(1, 0, 0, 1)</td>
</tr>
<tr>
<td>3</td>
<td>(0, 1, 0, 1)</td>
</tr>
<tr>
<td>4</td>
<td>(0, 1, 0, 1)</td>
</tr>
<tr>
<td>5</td>
<td>(0, 1, 0, 1)</td>
</tr>
</tbody>
</table>
<p>and the array is [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1]</p>
<p>Adding to the code</p>
<pre><code class="lang-javascript">var customMesh = new BABYLON.Mesh(&quot;custom&quot;, scene);

var positions = [-5, 2, -3, -7, -2, -3, -3, -2, -3, 5, 2, 3, 7, -2, 3, 3, -2, 3];
var indices = [0, 1, 2, 3, 4, 5];
var colors = [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0,  0, 1, 0, 1]; //color array added

var normals = [];

var vertexData = new BABYLON.VertexData();
BABYLON.VertexData.ComputeNormals(positions, indices, normals);

vertexData.positions = positions;
vertexData.indices = indices;
vertexData.colors = colors; //Assignment of colors to vertexData
vertexData.normals = normals; //Assignment of normal to vertexData added

vertexData.applyToMesh(customMesh);
</code></pre>
<p>In the playground below see what happens when you make the vertices on the red facet different colors.</p>
<p><a href="http://www.babylonjs-playground.com/#VKBJN#8">Playground Example Setting Vertex Colors</a> - <i class="fa fa-eye" onclick="createIframe('VKBJN#8', this)"></i><br/><div class="iframeContainer"></div><br/> </p>
<h3><a name="notes-on-the-playground" class="anchor" href="#notes-on-the-playground"></a>Notes on the Playground</h3><p>Since a material is no longer being used backFaceCulling cannot be set and so the camera will have to be rotated for the far facet to be seen. The far facet will remain black 
whatever color is applied since all light is still being absorbed by this facet. When the scene starts the camera is very nearly full face on 
to the facet and pointing in the dirrection the light is travelling. With the camera in this position most of the white light is reflected back into the camera as a highlight
and the facet is seen as almost white. As the camera is rotated around the facet will change from appearing as white to red as the highlight effect disipates. For a more 
controlled lighting effects use a <a href="/basics/Materials.html">material</a> as well as, or instead of, setting vertex colors.</p>
<h2><a name="texture" class="anchor" href="#texture"></a>Texture</h2><p>The simplest method is to just use <a href="/basics/Materials.html">materials</a> and let BabylonJS apply the given image as a texture. 
However should you wish to have more control on how a texture is applied to a facet then you need to create and set the uv array.</p>
<p>Think of any image, to be applied as a texture, as having a pair of axes set at the bottom and left hand side of the image, the u axis and the v axis respectively. 
(u, v as x and y are used for position axes). The origin being the left hand bottom corner of the image, the top being at v = 1 and the right hand edge at u = 1 as 
in the diagram below.</p>
<p><img src="/img/uv1.jpg" alt="Image with uv axes"></p>
<p>For simplication the following only uses the facet 0, 1, 2</p>
<p>Each vertex of the facet is assigned a uv coordinate pair from the image. </p>
<p><img src="/img/uv2.jpg" alt="Image with uv triangle"></p>
<table>
<thead>
<tr>
<th>index</th>
<th>color</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(0, 1)</td>
</tr>
<tr>
<td>1</td>
<td>(0, 0)</td>
</tr>
<tr>
<td>2</td>
<td>(1, 0)</td>
</tr>
</tbody>
</table>
<p>forming the uv array [0, 1, 0, 0, 1, 0];</p>
<p>Using the following code</p>
<pre><code class="lang-javascript">var customMesh = new BABYLON.Mesh(&quot;custom&quot;, scene);

var positions = [-5, 2, -3, -7, -2, -3, -3, -2, -3];
var indices = [0, 1, 2];
var uvs = [0, 1, 0, 0, 1, 0];

var normals = [];
BABYLON.VertexData.ComputeNormals(positions, indices, normals);

var vertexData = new BABYLON.VertexData();

vertexData.positions = positions;
vertexData.indices = indices;
vertexData.normals = normals;
vertexData.uvs = uvs;

vertexData.applyToMesh(customMesh);
</code></pre>
<p>results in </p>
<p><img src="/img/uv3.jpg" alt="Result on Facet"></p>
<p>Note that the image is skewed since the shape of the triangular facet and that on the image do not match.</p>
<p>Adding in these lines at the appropiate points</p>
<pre><code class="lang-javascript">var colors = [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1];

var vertexData.colors = colors;
</code></pre>
<p>gives </p>
<p><img src="/img/uv4.jpg" alt="Result on Facet with red color added"></p>
<p>In the playground below clicking on next will cycle you through a variety of values for the uv coordinates.</p>
<p><a href="http://www.babylonjs-playground.com/#VKBJN#14">Playground Example Varying UV Values</a> - <i class="fa fa-eye" onclick="createIframe('VKBJN#14', this)"></i><br/><div class="iframeContainer"></div><br/> </p>
<h3><a name="notes-on-playground" class="anchor" href="#notes-on-playground"></a>Notes on Playground</h3><p>The camera has been disabled for this playground. The uv values are shown and the relative index are shown on the texture image. 
One day this might improve. You will get some idea of how to achieve reflections and rotations of textures on a facet. However for a mesh 
the <a href="/advanced/Facets.html">arrangement of facets</a> must be considered when trying to achieve a particular texture mapping on the mesh.</p>
<h1><a name="further-reading" class="anchor" href="#further-reading"></a>Further Reading</h1><p><a href="/advanced/Updating_Vertices.html">Updating Vertices</a><br><a href="/advanced/Normals.html">Normals in BJS</a></p>
</div></div></div><footer class="footer"><div class="footer-item"><a href="http://www.html5gamedevs.com/forum/16-babylonjs" target="_blank"><i class="fa fa-html5"></i>    Forum</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Babylon.js" target="_blank"><i class="fa fa-github"></i>    Github</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Documentation" target="_blank"><i class="fa fa-code-fork"></i>    Contribute</a></div><div class="footer-item"><a href="http://doc.babylonjs.com/" target="_blank"><i class="fa fa-html5"></i>    Official Documentation        </a></div></footer><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/0.1.9/slideout.min.js"></script><script src="/js/index.js"></script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-66146410-1', 'auto');
ga('send', 'pageview');</script><!-- HIGHLIGHT JS--><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/javascript.min.js"></script><script src="/js/static.js"></script><script>$('code').each(function(){
    $(this).text($(this).text().replace(/&nbsp;/gi, ''));
});
hljs.initHighlightingOnLoad();</script></body></html>