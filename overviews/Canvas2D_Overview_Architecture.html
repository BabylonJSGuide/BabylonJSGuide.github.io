<!DOCTYPE html><html><head lang="en"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>BabylonJS Guide</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" href="/css/libs/slideout.css"><link rel="stylesheet" href="/css/libs/highlight/github.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.3/css/perfect-scrollbar.min.css"><link rel="stylesheet" href="/css/main.css"></head><body><nav id="menu"></nav><nav class="nav-main"><!-- Hamburger menu : displayed only in small screens--><i id="mobilemenu" class="fa fa-bars"></i><!-- this button only shows on mobile version of a "class" page--><div class="banner"><div class="menu"><div id="home" class="do-not-hover"><a href="/">Babylon.js | GUIDE</a></div><div id="begin" class="item"><a href="/begins.html">Begin Here</a></div><div id="tutorials" class="item"><a href="/tutorials.html">Tutorials</a></div><div id="overview" class="item active"><a href="/overviews.html">Overviews</a></div><div id="exporters" class="item"><a href="/exporters.html">Exporters</a></div><div id="extensions" class="item"><a href="/extensions.html">Extensions</a></div></div><div class="more"><div class="searchbar"><form method="get" action="/search"><input type="text" name="q" placeholder="Search..."><button type="submit"><i class="fa fa-search"></i></button></form></div></div></div></nav><div id="wrapper"><div class="statics-banner"><h1>overviews</h1></div><div class="horizontal-separator"></div><div class="static-content"><h1>Canvas 2D overview and architecture</h1><br><div class="contentTable"><div class="tocHeader"><span class="tocTitle"><i class="tocIcon fa fa-book"></i>Table of contents</span><span class="tocToggle"><i class="fa fa-arrow-up"></i></span></div><div class="tocContent"><ul>
<li><a href="#few-useful-links">Few useful links</a><ul>
<li><a href="#features-overview">Features overview</a></li>
<li><a href="#basic-types">Basic Types</a></li>
</ul>
</li>
<li><a href="#prim2dbase">Prim2DBase</a></li>
<li><a href="#group2d">Group2D</a></li>
<li><a href="#canvas2d">Canvas2D</a></li>
<li><a href="#renderableprim2d">RenderablePrim2D</a></li>
<li><a href="#shape2d">Shape2D</a></li>
<li><a href="#brushes">Brushes</a><ul>
<li><a href="#canvas-group2d-caching-behaviors">Canvas &amp; Group2D caching behaviors</a></li>
</ul>
</li>
<li><a href="#canvas-caching-strategy">Canvas Caching Strategy</a></li>
<li><a href="#group-cache-behavior">Group Cache Behavior</a><ul>
<li><a href="#architecture">Architecture</a></li>
</ul>
</li>
<li><a href="#the-primitive-caching-mechanisms">The Primitive Caching mechanisms</a><ul>
<li><a href="#properties-level">Properties Level</a></li>
<li><a href="#the-model-render-cache-class">The Model Render Cache class</a></li>
<li><a href="#the-instancedata-class">The InstanceData class</a></li>
<li><a href="#automatic-dirtyproperty-change">Automatic dirty/property change</a></li>
</ul>
</li>
<li><a href="#rendering">Rendering</a><ul>
<li><a href="#transformation-and-visibility-update">Transformation and Visibility update</a></li>
<li><a href="#primitive-preparation">Primitive preparation</a></li>
<li><a href="#rendering">Rendering</a></li>
</ul>
</li>
</ul>
</div></div><div id="staticContent"><h1><a name="babylonjs-2d-rendering-canvas-canvas2d" class="anchor" href="#babylonjs-2d-rendering-canvas-canvas2d"></a>Babylon.js 2D Rendering Canvas (Canvas2D)</h1><p>Babylon.js is a full featured 3D engine, but the need to handle 2D content is often encountered when working on games or complex applications.
It is to provide an answer to this demand that we&#39;ve developed the Canvas2D feature.</p>
<p>Canvas2D in a <strong>non HTML</strong> feature, <strong>100% WebGL</strong> based, developed to serve the purpose of drawing 2D Content.</p>
<h3><a name="few-useful-links" class="anchor" href="#few-useful-links"></a>Few useful links</h3><p>Go to the <a href="http://doc.babylonjs.com/overviews/Canvas2D_Home">Home Page</a> as a good starting point.</p>
<p>For a first-time learning tutorial <a href="http://doc.babylonjs.com/tutorials/Using_the_Canvas2D">go there</a>.</p>
<p>To learn how to develop your own Primitive type, <a href="http://doc.babylonjs.com/tutorials/How_to_create_your_own_Canvas2D_primitive">it&#39;s here</a>.</p>
<h2><a name="features-overview" class="anchor" href="#features-overview"></a>Features overview</h2><p>A Canvas2D is a 2D rectangle with a position and a size, the size can be specified by the user or it is automatically computed to fit its content. To follow Open/WebGL standard, the origin of the canvas is at the <strong>bottom/left</strong> corner and not at the top/left as one would expect.</p>
<p>The Canvas can be rendered in two different spaces:</p>
<ul>
<li><strong>ScreenSpace</strong>: it lies above the rendered 3D Scene and is coplanar to the rendering viewport. Its position/rotation/scale is expressed in screen coordinate, with the origin being the top/left corner of the rendering viewport.</li>
<li><strong>WorldSpace</strong>: the canvas has a position/rotation/scale that is expressed in World Coordinates, your canvas is like a 2D Rectangle lying in World Space, like any other 3D objects you can find in a 3D Scene.</li>
</ul>
<p>In order to preserve a good balance between rendering time and memory consumption the user has the possibility to cache in a bitmap the content of a Group. Many caching strategies are predefined, hopefully for the user to always find what fits him/her the best.</p>
<p>The content of a Canvas is defined by a graph of primitives, they are rendered using Brushes (Border, Fill) &amp;| Textures.</p>
<h2><a name="basic-types" class="anchor" href="#basic-types"></a>Basic Types</h2><p>Here is the basic types to work with.</p>
<h3><a name="prim2dbase" class="anchor" href="#prim2dbase"></a>Prim2DBase</h3><p>This is the base class for any object that are part of the content graph of a Canvas.
It features properties such as:</p>
<ul>
<li>Transformation properties: Position/Rotation/Scale. Position being X,Y, Rotation being a number in radian for the rotation along the Z axis, Scale being a number to provide uniform scale.</li>
<li>Origin: define the origin of the primitive, default being 0.5,0.5, which is the center of the primitive, 0.0,0.0 would be the top/left corner of the primitive.</li>
<li>LevelVisibility: define the visibility set for this particular Primitive, it&#39;s <strong>not</strong> the actual visibility in the canvas, see below.</li>
<li>The IsVisible property will inform if the Primitive will be rendered or not in the Canvas. The visibility concept is hierarchical, if a Primitive has at least one parent set as not visible, it won&#39;t be too.</li>
<li>zOrder. While the hierarchy give a sense of Z ordering (children being place above parents), the user can override it through this property.</li>
<li>boundingInfo, every primitive has a bounding information maintained automatically. This info describe a bounding circle (with a Radius) and a bounding box (with a 2D Vector acting as the extent).</li>
<li>Parent/Children: to navigate through the graph.</li>
</ul>
<h3><a name="group2d" class="anchor" href="#group2d"></a>Group2D</h3><p>Acts as a container for its children, has no rendering itself. A group define a new frame of reference, the visibility status will also be applied to its children. Based on the Caching strategy defined at the Canvas level and also the Caching Behavior of the group, its content will be cached to a bitmap or rendered during the viewport rendering.</p>
<h3><a name="canvas2d" class="anchor" href="#canvas2d"></a>Canvas2D</h3><p>The main class that describes a Canvas, it derives from Group2D, inheriting its capabilities. A given Canvas belong to a given Scene, it&#39;s either defined in ScreenSpace or WorldSpace, may have a Background &amp;| Border.</p>
<h3><a name="renderableprim2d" class="anchor" href="#renderableprim2d"></a>RenderablePrim2D</h3><p>This is an abstract class, used for primitives that render in the Canvas. This class takes care of the model and instance caching of the rendering resources.</p>
<h3><a name="shape2d" class="anchor" href="#shape2d"></a>Shape2D</h3><p>This is the abstract to describe a generic shape, which is a 2D form, displayed either or both a border and fill content.</p>
<h3><a name="brushes" class="anchor" href="#brushes"></a>Brushes</h3><p>There&#39;s a IBrush2D TypeScript interface that can be implemented to define a specific type of Brush, that would be used to render a part or the totality of a Primitive.
Right now SolidColorBrush2D and GradientColorBrush2D are implemented</p>
<h2><a name="canvas-amp-group2d-caching-behaviors" class="anchor" href="#canvas-group2d-caching-behaviors"></a>Canvas &amp; Group2D caching behaviors</h2><p>It is critical to understand that Groups are defined either as Renderable or not (say Logical) and Cached or not.
This is defined by setting the Canvas Caching Strategy and overriding it at a Group Level with its cacheBehavior property.</p>
<p>A Renderable Group will contains the list of the primitive it&#39;s responsible to update and render.
A Logical Group will merely act as a container, a new reference frame which doesn&#39;t play a part in the rendering process.</p>
<p>If a Group is Renderable, it can be:</p>
<ul>
<li>Cached, its whole content until the next Renderable Group down the graph will be Cached into a bitmap.</li>
<li>Not Cached, its whole content until the next Renderable Group down the graph will be rendered every time.</li>
</ul>
<h3><a name="canvas-caching-strategy" class="anchor" href="#canvas-caching-strategy"></a>Canvas Caching Strategy</h3><p>When a Canvas is created you have to choose a Caching Strategy, one of these:</p>
<ul>
<li><code>CACHESTRATEGY_TOPLEVELGROUPS</code> The Canvas itself won&#39;t be cached, but each of its direct children group will be cached (so their content, also including sub groups). If you have a Canvas spanning the whole rendering viewport (say 1920*1080 pixels) and the content of the Canvas is only one small Group at the Top Left and another at the Bottom Right of the viewport, then you don&#39;t want to cache the whole screen for that less. This mode will only create a cache bitmap for the space taken by the two groups.</li>
<li><code>CACHESTRATEGY_ALLGROUPS</code> The Canvas and each group will have their own cache, unless you change this behavior using the Group2D.cacheBehavior). This is by far the most memory consuming, but efficient if the content change frequently but at different pace. You can reduce greatly the amount of cache with Group2D.cacheBehavior though.</li>
<li><code>CACHESTRATEGY_CANVAS</code> Only the Canvas and its whole content will be cached. Simple and efficient if its size is ok for you and its content doesn&#39;t change every frame.</li>
<li><code>CACHESTRATEGY_DONTCACHE</code> Nothing is cached, every primitives are rendered every frame in the Viewport. Note this mode can only be chosen for ScreenSpace Canvas, World Space ones has to be cached at some level.</li>
</ul>
<h3><a name="group-cache-behavior" class="anchor" href="#group-cache-behavior"></a>Group Cache Behavior</h3><p>Each instance of Group2D has a cacheBehavior property, with one of the following values:</p>
<ul>
<li><code>GROUPCACHEBEHAVIOR_FOLLOWCACHESTRATEGY</code> Follow the strategy defined at the Canvas level, this is the default value.</li>
<li><code>GROUPCACHEBEHAVIOR_DONTCACHEOVERRIDE</code> Don&#39;t cache the Group&#39;s content whatever the strategy defines for this group.</li>
<li><code>GROUPCACHEBEHAVIOR_CACHEINPARENTGROUP</code> Cache the group&#39;s content in the first parent group that is cached.</li>
</ul>
<h2><a name="architecture" class="anchor" href="#architecture"></a>Architecture</h2><h3><a name="the-primitive-caching-mechanisms" class="anchor" href="#the-primitive-caching-mechanisms"></a>The Primitive Caching mechanisms</h3><p>The challenge behind this feature is to render everything with the minimal amount of Draw Call and to compute/update the data needed for rendering only when necessary.</p>
<p>In order to reduce the WebGL Draw Calls, the architecture was designed to render the highest amount of instances of a given Primitive using the <a href="https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays/">Instanced Array feature</a> of WebGL. A fallback is available is the extension is not supported by the browser.</p>
<p>Several mechanisms are implemented to achieve that.</p>
<h4><a name="properties-level" class="anchor" href="#properties-level"></a>Properties Level</h4><p>Each Primitive type won&#39;t probably be able to render any variations of its instances in a single call, because of the limitations imposed by the Vertex/Fragment Shader. But it&#39;s certainly possible to put several instances sharing the same given set of property/value into a single call.</p>
<p>To achieve that we breakdown each property of a primitive into three possible categories:</p>
<ol>
<li>Model Level: each different value will lead to a specific render model, then one draw call. Two instances having two different values for a given property will lead to two different models to render.</li>
<li>Instance Level: the property can have any kind of value, it won&#39;t change the render model assigned to the instance.</li>
<li>Dynamic Level: the property doesn&#39;t play a part in the rendering.</li>
</ol>
<p>For instance the Sprite2D Primitive has the following properties:</p>
<ul>
<li>texture (model): the texture to use to render the sprite</li>
<li>spriteSize (instance): the size of the sprite</li>
<li>spriteLocation (instance): the location into the texture of the top/left corner of the sprite.</li>
</ul>
<p>If we have three sprites: A, B, C. A and C are using the same texture, B is using another one. We will end up with two rendering models: one for A and C and another one for B. A and C will be drawn into a single call and B will also have one call for itself.</p>
<h4><a name="the-model-render-cache-class" class="anchor" href="#the-model-render-cache-class"></a>The Model Render Cache class</h4><p>When an instance is about to be rendered, we access its Model Render Cache, it&#39;s an instance of a class dedicated to this primitive type which stores all the information to perform the rendering.</p>
<p>For a given type of Primitive there&#39;s as many different Model Render Cache instance as there&#39;s different combinations of properties declare with the Model Level.</p>
<p>Each primitive instance has a modelKey (accessible through the property &#39;modelKey&#39;) which is computed based on the primitive type and the different model level properties name+value.</p>
<p>The Model Render Cache creates all the resources to render the list of instances it has. If the user change the value of a property tagged with the Model Level, then its rendering instance will be removed from the old Model Render Cache and a new one will be created into the appropriate one.</p>
<p>A per primitive instance object is also created, it contains all the data that will be stored in the Instancing Array.</p>
<p>A third dedicated type is needed for each primitive type in order to describe these data that will fill the Instancing Array, that&#39;s the Instance Data.
Complex Primitives may be broke down into many different types of Instance Data, which are called <strong>Parts</strong>, for instance a Shape2D has a Border Part and a Fill Part. This will lead to two separated drawing calls.</p>
<p>A Primitive can stores <em>nth</em> instances of a Part. For instance the Text2D Primitive will store one Part Instance per letter contained in the displayed Text. All letters of all Text2D Primitives sharing the same font will be drawn in one call, which is very efficient.</p>
<p>Finally each property defined in a given InstanceData can belong to a category to make it optional. This is needed to support many types of Brushes in the same implementation of a Primitive Shaders.
For instance a Rectangle2D has a set of properties for the SolidColorBrush2D (just a Color4 for Border and Fill) and another one for the GradientColorBrush2D (Color1, Color2, Transformation information, for both Border and Fill).
The Canvas2D will take care of pretty much everything for the developers, creating the data array that will be mapped to the Instanced Array based on what combination is used, synchronize them, inject the right information in the Effect created to render the primitive (Attribute, Uniform, Defines) and setup everything up before the render call is submitted. This flexibility is achieved thanks to the decorator you use to describe a Primitive and its Instance Data.</p>
<p>To sum up, for the Sprite2D primitive we have:</p>
<ul>
<li>Sprite2D: the main class the user of the Canvas2D deals with to create sprites in the Canvas.</li>
<li>Sprite2DRenderCache: a ModelRenderCache extended class that create the vertex buffer, index buffer, store the texture, the rendering effect, implements the rendering method and also hold the list of all instances using this model. The Instanced Array buffer containing the data to send to the GPU during the DrawInstanced call are store into another class call the GroupInstanceInfo, which is controlled by a Renderable Group and contains all the data the Group is supposed to render for this specific model.</li>
<li>Sprite2DInstanceData: which extends the InstanceDataBase class and serves as a proxy to declare the properties that will end up in the Instancing Array. The list so far:<ul>
<li>For InstanceDataBase: zBias (to compute the depth value), transformX and transformY (to transform the primitive vertices at the right location), origin (needed for the vertices position calculation)</li>
<li>For Sprite2D: topLeftUV (location in the texture of the sprite), sizeUV (size of the sprite), textureSize (to compute the on-screen size of the sprite), frame (for animated sprites, the frame number) and invertY (to invert the texture V coordinates)</li>
</ul>
</li>
</ul>
<h4><a name="the-instancedata-class" class="anchor" href="#the-instancedata-class"></a>The InstanceData class</h4><p>Luckily for the developer that implements new primitives type, the wiring of the data to take from an instance of a primitive to put in the Instance Array is automatically made.
For this to happens each primitive type has a dedicated InstanceData class (extending the InstanceData matching the Primitive class it extends) which declare the properties to store in the Instancing Array.
All you have to do is declaring a property this way:</p>
<pre><code class="lang-Javascript">export class Sprite2DInstanceData extends InstanceDataBase {
    @instanceData()
    get topLeftUV(): Vector2 {
        return null;
    }
    ...
}
</code></pre>
<p>The @instanceData decorator will take care of providing a real getter/setter to the property, which will be used to make the wiring.</p>
<p>The primitive based class (Sprite2D in our case) must implements the refreshInstancaData() method which will be called to update the data. This method may contains a little logic/transformation because the properties exposed by the primitive are not necessary represented the same way in the Vertex Shader.</p>
<p>Take a look at the Rectangle2D and Text2D classes (and their base classes) for more information of what and how you can do your own Primitives.</p>
<h4><a name="automatic-dirtyproperty-change" class="anchor" href="#automatic-dirtyproperty-change"></a>Automatic dirty/property change</h4><p>Each property in a primitive that is decorated with either @modelLevelProperty, @instanceLevelProperty or @dynamicLevelProperty will have its setter function overloaded in order to provide the following services:</p>
<ul>
<li>Detect if the change of value will impact the way the primitive should be rendered and add it to the list of primitives to update for rendering.</li>
<li>Maintain a dirty flag when this property has a value change between two renders</li>
<li>Dirty the boundingInfo if needed</li>
<li>Notify observers of the data change</li>
</ul>
<p>The implementer doesn&#39;t have to take care of these things, it&#39;s free!</p>
<p><strong>WARNING</strong>: for custom type properties like Vector3 for instance, changing only the .x/y/z won&#39;t trigger a property change and nothing will happen. You have to assign a new object for the change to be detected!</p>
<h3><a name="rendering" class="anchor" href="#rendering"></a>Rendering</h3><p>Rendering of a Canvas is made is in three parts:</p>
<ol>
<li>Preparation of the transformation matrices and update the visibility status of each primitive</li>
<li>Preparation of the primitives that are dirty for rendering</li>
<li>Do the rendering</li>
</ol>
<h4><a name="transformation-and-visibility-update" class="anchor" href="#transformation-and-visibility-update"></a>Transformation and Visibility update</h4><p>This step is done on each primitive that had a position based property that changed, same for visibility.
Only a part of the graph is traversed, from the primitives that changed down to its children.
No change will lead to zero node traversing in the graph.</p>
<h4><a name="primitive-preparation" class="anchor" href="#primitive-preparation"></a>Primitive preparation</h4><p>The first time a primitive is to render or when on of its property (tagged with the xxxLevelProperty decorator) changed, it needs to be prepared.
This is made on a per Renderable Group basis, each Renderable Group are traversed and if one has some dirty primitive it will update their rendering resources optimally (model change &amp;| instance change). A dirty primitive may lead to a dirty of its children ones, which is also taken care by this stage.</p>
<h4><a name="rendering" class="anchor" href="#rendering"></a>Rendering</h4><p>Rendering is made by traversing Renderable Groups, respecting the Cached mode. If a group is Cached its content will be displayed by its parent Renderable Group into a Sprite2D targeting the bitmap&#39;s content.</p>
<p>If rendering resources are not ready (texture or effect still loading), the primitive will be let as dirty for render and then rendering will be retried next round.</p>
</div></div></div><footer class="footer"><div class="footer-item"><a href="http://www.html5gamedevs.com/forum/16-babylonjs" target="_blank"><i class="fa fa-html5"></i>    Forum</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Babylon.js" target="_blank"><i class="fa fa-github"></i>    Github</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Documentation" target="_blank"><i class="fa fa-code-fork"></i>    Contribute</a></div><div class="footer-item"><a href="http://doc.babylonjs.com/" target="_blank"><i class="fa fa-html5"></i>    Official Documentation        </a></div></footer><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/0.1.9/slideout.min.js"></script><script src="/js/index.js"></script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-66146410-1', 'auto');
ga('send', 'pageview');</script><!-- HIGHLIGHT JS--><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/javascript.min.js"></script><script src="/js/static.js"></script><script>$('code').each(function(){
    $(this).text($(this).text().replace(/&nbsp;/gi, ''));
});
hljs.initHighlightingOnLoad();</script></body></html>