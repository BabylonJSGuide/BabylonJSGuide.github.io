<!DOCTYPE html><html style="height:100%;"><head lang="en"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="wcRjktXhF6DAjmhneKS7UatweBIkEF6QfqsNhAYbUgg"><title>Using Build a House from a Floorplan - Babylon.js Documentation</title><link rel="shortcut icon" href="/img/favicon.ico"><meta name="msapplication-TileColor" content="#ffffff"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="https://use.typekit.net/cta4xsb.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" href="/css/libs/slideout.css"><link rel="stylesheet" href="/css/libs/highlight/github.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.3/css/perfect-scrollbar.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/styles/default.min.css"></head><body><nav id="menu"></nav><nav class="nav-main" style="position:inherit;"><!-- Hamburger menu : displayed only in small screens--><i class="fa fa-bars" id="mobilemenu"></i><div class="banner"><div class="menu"><div class="do-not-hover" id="home"><a href="/">HOME</a></div><div class="item" id="whatsnew"><a href="/whats-new">What's new</a></div><div class="item" id="feature"><a href="/babylon101">Babylon 101      </a></div><div class="item" id="feature"><a href="/examples">Examples                        </a></div><div class="item" id="How_To"><a href="/How_To">How To...</a></div><div class="item" id="feature"><a href="/features">Features</a></div><div class="item" id="resources"><a href="/resources">Resources</a></div><div class="item" id="extensions"><a href="/extensions">Extensions</a></div><div class="item active" id="samples"><a href="/snippets">Snippets        </a></div><div class="item" id="classes"><a href="/api">API</a></div><div class="item" id="playground"><a href="/playground">Playground</a></div></div><div class="more"><div class="searchbar"><form method="get" action="/search"><input type="text" name="bjsq" placeholder="Search..."><button type="submit"><i class="fa fa-search"></i></button></form></div></div></div></nav><div id="wrapper"><div class="statics-banner"><div class="img-holder details"><a href="/"><img src="/img/babylonjs_identity_color_dark.svg"></a><a href="/snippets"><h1>snippets</h1></a><div></div></div></div><div class="horizontal-separator"></div><div class="static-content"><h1>Using Build a House from a Floorplan</h1><br><div class="contentTable"><div class="tocHeader"><span class="tocTitle"><i class="tocIcon fa fa-book"></i>Table of contents</span><span class="tocToggle"><i class="fa fa-chevron-up"></i></span></div><div class="tocContent"><ul>
<li><a href="#code">Code</a><ul>
<li><a href="#buildfromplan">buildFromPlan</a></li>
<li><a href="#polygonmeshbuilder-wallbuilder-method">PolygonMeshBuilder wallBuilder Method</a></li>
<li><a href="#building-the-data-and-parameters-an-example">Building the Data and Parameters, an example</a></li>
<li><a href="#build-interior-walls">Build Interior Walls</a></li>
</ul>
</li>
<li><a href="#playground-examples">Playground Examples</a><ul>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
</li>
<li><a href="#level-1">Level 1</a></li>
<li><a href="#level-2">Level 2</a></li>
</ul>
</div></div><div id="staticContent"><h1><a name="using-build-a-house-from-plans" class="anchor" href="#using-build-a-house-from-plans"></a>Using Build a House from Plans.</h1><p><strong>Please note that some functions used in this project uses Earcut, so, in non playground projects, you will have to add a reference to their <a href="https://unpkg.com/earcut@2.1.1/dist/earcut.min.js">cdn</a> or download their <a href="https://github.com/mapbox/earcut#install">npm package</a></strong></p>
<p>The walls, doors and windows of a house can be built using the function </p>
<pre><code class="lang-javascript">var house buildFromPlan(walls, ply, height, options, scene);
</code></pre>
<p>which requires an additional prototype to <code>PolygonMeshBuilder</code>.</p>
<p>The code for both of these is given below and can be copied and used in your own projects. Further details can be found by reading the <a href="/samples/House">development of this code</a>. </p>
<p>The parameters are</p>
<p><em>walls</em> : an array of wall objects<br><em>ply</em> : thickness of each wall<br><em>height</em> : height of each wall<br><em>options</em> : an object containing 5 optional parameters<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interior: a Boolean, default false, when set to true can be used to draw interior walls<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interiorUV: a Vector4(bottom left u, bottom left v, top right u, top right v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exteriorUV: a Vector4(bottom left u, bottom left v, top right u, top right v)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interiorColor: a Color4(r, g, b, a)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exteriorColor: a Color4(r, g, b, a)<br><em>scene</em> : the scene</p>
<p>Each wall object has one two or three parameters</p>
<p><em>corners</em>: an array of corner objects - required<br><em>doorSpaces</em> : an array of doorSpace objects - optional<br><em>windowSpaces</em> an array of windowSpace objects - optional   </p>
<p>Each corner object has two parameters giving its position in 2D , example new corner(-3, 2)</p>
<p>Each doorSpace object has two parameters
<em>door</em> : door object<br><em>left</em> : distance from left hand edge of wall  </p>
<p>Each door object has two parameters, example new door(2, 1)
<em>width</em> : width of door<br><em>height</em> : height of door</p>
<p>Each windowSpace object has three parameters
<em>window</em> : window object<br><em>left</em> : distance from left hand edge of wall<br><em>top</em> : distance from top of wall  </p>
<p>Each window object has two parameters, example new window(1, 2)
<em>width</em> : width of window<br><em>height</em> : height of window</p>
<h2><a name="code" class="anchor" href="#code"></a>Code</h2><h3><a name="buildfromplan" class="anchor" href="#buildfromplan"></a>buildFromPlan</h3><p>The following code should be copied and pasted inside the <code>createScene</code> function</p>
<pre><code class="lang-javascript">var buildFromPlan = function(walls, ply, height, options, scene) {

    //Arrays for vertex positions and indices
    var positions = [];
    var indices = [];
    var uvs = [];
    var colors = [];

    var interiorUV = options.interiorUV || new BABYLON.Vector4(0, 0, 1, 1);
    var exteriorUV = options.exteriorUV || new BABYLON.Vector4(0, 0, 1, 1);

    var interiorColor = options.interiorColor || new BABYLON.Color4(1, 1, 1, 1);
    var exteriorColor = options.exteriorColor || new BABYLON.Color4(1, 1, 1, 1);        
    var interior = options.interior || false;
        if(!interior) {
            walls.push(walls[0]);
        }

    var interiorIndex;

    //Arrays to hold wall corner data 
    var innerBaseCorners = [];
    var outerBaseCorners = [];
    var innerTopCorners = [];
    var outerTopCorners = [];
    var innerDoorCorners = [];
    var outerDoorCorners = [];
    var innerWindowCorners = [];
    var outerWindowCorners = [];

    var angle = 0;
    var direction = 0;

        var line = BABYLON.Vector3.Zero();
        var nextLine = BABYLON.Vector3.Zero();        

        var nbWalls = walls.length;
        if(nbWalls === 2) {
            walls[1].corner.subtractToRef(walls[0].corner, line);
            lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
        line.normalize();
            innerBaseCorners[0] = walls[0].corner;
            outerBaseCorners[0] = walls[0].corner.add(lineNormal.scale(ply));
            innerBaseCorners[1] = walls[1].corner;
            outerBaseCorners[1] = walls[1].corner.add(lineNormal.scale(ply));
        }
        else if(nbWalls &gt; 2) { 
            for(var w = 0; w &lt; nbWalls - 1; w++) {
                walls[w + 1].corner.subtractToRef(walls[w].corner, nextLine);
                angle = Math.PI - Math.acos(BABYLON.Vector3.Dot(line, nextLine)/(line.length() * nextLine.length()));            
            direction = BABYLON.Vector3.Cross(nextLine, line).normalize().y;            
            lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
            line.normalize();
                innerBaseCorners[w] = walls[w].corner
                outerBaseCorners[w] = walls[w].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply/Math.tan(angle/2)));        
            line = nextLine.clone();
            } 
            if(interior) {
                lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
            line.normalize();
                innerBaseCorners[nbWalls - 1] = walls[nbWalls - 1].corner
                outerBaseCorners[nbWalls - 1] = walls[nbWalls - 1].corner.add(lineNormal.scale(ply));
                walls[1].corner.subtractToRef(walls[0].corner, line);
                lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
            line.normalize();
                innerBaseCorners[0] = walls[0].corner;
                outerBaseCorners[0] = walls[0].corner.add(lineNormal.scale(ply));
            }
            else {
                walls[1].corner.subtractToRef(walls[0].corner, nextLine);
                angle = Math.PI - Math.acos(BABYLON.Vector3.Dot(line, nextLine)/(line.length() * nextLine.length()));            
            direction = BABYLON.Vector3.Cross(nextLine, line).normalize().y;            
            lineNormal = new BABYLON.Vector3(line.z, 0, -1 * line.x).normalize();
            line.normalize();
                innerBaseCorners[0] = walls[0].corner
                outerBaseCorners[0] = walls[0].corner.add(lineNormal.scale(ply)).add(line.scale(direction * ply/Math.tan(angle/2)));
                innerBaseCorners[nbWalls - 1] = innerBaseCorners[0];
                outerBaseCorners[nbWalls - 1] = outerBaseCorners[0]

            }       
        }

    // inner and outer top corners
    for(var w = 0; w &lt; nbWalls; w++) {
        innerTopCorners.push(new BABYLON.Vector3(innerBaseCorners[w].x, height, innerBaseCorners[w].z));
        outerTopCorners.push(new BABYLON.Vector3(outerBaseCorners[w].x, height, outerBaseCorners[w].z));
    }

    var maxL = 0;
    for(w = 0; w &lt; nbWalls - 1; w++) {
        maxL = Math.max(innerBaseCorners[w + 1].subtract(innerBaseCorners[w]).length(), maxL);
    }

    var maxH = height; // for when gables introduced

    /******House Mesh Construction********/

    // Wall Construction
    var polygonCorners;
    var polygonTriangulation;
    var wallData;
    var wallDirection = BABYLON.Vector3.Zero();
    var wallNormal = BABYLON.Vector3.Zero(); 
    var wallLength;
    var exteriorWallLength;
    var doorData;
    var windowData;
    var uvx, uvy;
    var wallDiff;

    for(var w = 0; w &lt; nbWalls - 1; w++) {
        walls[w + 1].corner.subtractToRef(walls[w].corner, wallDirection);
        wallLength = wallDirection.length();
        wallDirection.normalize();
        wallNormal.x = wallDirection.z;
        wallNormal.z = -1 * wallDirection.x;
        exteriorWallLength = outerBaseCorners[w + 1].subtract(outerBaseCorners[w]).length();
        wallDiff = exteriorWallLength - wallLength;
        var gableHeight = 0;

        //doors
        if(walls[w].doorSpaces) {
            walls[w].doorSpaces.sort(compareLeft);
        }
        var doors = walls[w].doorSpaces.length;

        //Construct INNER wall polygon starting from (0, 0) using wall length and height and door data
        polygonCorners = [];
        polygonCorners.push(new BABYLON.Vector2(0, 0));

        for (var d = 0; d &lt; doors; d++) {            
            polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left, 0));
            polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left, walls[w].doorSpaces[d].door.height));
            polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left + walls[w].doorSpaces[d].door.width, walls[w].doorSpaces[d].door.height));
            polygonCorners.push(new BABYLON.Vector2(walls[w].doorSpaces[d].left + walls[w].doorSpaces[d].door.width, 0));            
        }

        polygonCorners.push(new BABYLON.Vector2(wallLength, 0));
        polygonCorners.push(new BABYLON.Vector2(wallLength, height));
        polygonCorners.push(new BABYLON.Vector2(0, height));

        //Construct triangulation of polygon using its corners
        polygonTriangulation = new BABYLON.PolygonMeshBuilder(&quot;&quot;, polygonCorners, scene);    

        //windows
        //Construct holes and add to polygon from window data            
        var windows = walls[w].windowSpaces.length;
        var holes = [];
        for(var ws = 0; ws &lt; windows; ws++) { 
            var holeData = [];
            holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left, height - walls[w].windowSpaces[ws].top - walls[w].windowSpaces[ws].window.height));
            holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left + walls[w].windowSpaces[ws].window.width, height - walls[w].windowSpaces[ws].top - walls[w].windowSpaces[ws].window.height));
            holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left + walls[w].windowSpaces[ws].window.width, height - walls[w].windowSpaces[ws].top));
            holeData.push(new BABYLON.Vector2(walls[w].windowSpaces[ws].left, height - walls[w].windowSpaces[ws].top));
            holes.push(holeData);                
        }

        for(var h = 0; h &lt; holes.length; h++) {
            polygonTriangulation.addHole(holes[h]);
        }


        // wallBuilder produces wall vertex positions array and indices using the current and next wall to rotate and translate vertex positions to correct place
        wallData = polygonTriangulation.wallBuilder(walls[w], walls[w + 1]);    

        nbIndices = positions.length/3; // current number of indices

        polygonTriangulation._points.elements.forEach(function (p)  {
            uvx = interiorUV.x + p.x * (interiorUV.z - interiorUV.x) / maxL;
            uvy = interiorUV.y + p.y * (interiorUV.w - interiorUV.y) / height;
            uvs.push(uvx, uvy);                    
            colors.push(interiorColor.r, interiorColor.g, interiorColor.b, interiorColor.a);
        });

        //Add inner wall positions (repeated for flat shaded mesh)
        positions = positions.concat(wallData.positions);

        interiorIndex = positions.length/3;

        indices = indices.concat(wallData.indices.map(function(idx){
            return idx + nbIndices;
        }));

        //wallData has format for inner wall [base left, 0 or more doors, base right, top right, top left, windows]
        //extract door and wall data

        windowData = wallData.positions.slice(12 * (doors + 1)); //4 entries per door + 4 entries for wall corners, each entry has 3 data points
        doorData = wallData.positions.slice(3, 3 * (4 * doors + 1) ); 

        //For each inner door save corner as an array of four Vector3s, base left, top left, top right, base right
        //Extend door data outwards by ply and save outer door corners         
        var doorCornersIn = [];
        var doorCornersOut = [];
        for(var p = 0; p &lt; doorData.length/12; p++) {
            var doorsIn = [];
            var doorsOut = [];
            for(var d = 0; d &lt; 4; d ++) {
                doorsIn.push(new BABYLON.Vector3(doorData[3 * d + 12 * p], doorData[3 * d  + 12 * p + 1], doorData[3 * d + 12 * p + 2]));
                doorData[3 * d + 12 * p] += ply * wallNormal.x;
                doorData[3 * d + 12 * p + 2] += ply * wallNormal.z;
                doorsOut.push(new BABYLON.Vector3(doorData[3 * d + 12 * p], doorData[3 * d  + 12 * p + 1], doorData[3 * d + 12 * p + 2]));
            }
            doorCornersIn.push(doorsIn);
            doorCornersOut.push(doorsOut);
        }            
        innerDoorCorners.push(doorCornersIn);            
        outerDoorCorners.push(doorCornersOut);

        //For each inner window save corner as an array of four Vector3s, base left, top left, top right, base right
        //Extend window data outwards by ply and save outer window corners         
        var windowCornersIn = [];
        var windowCornersOut = [];
        for(var p = 0; p &lt; windowData.length/12; p++) {
            var windowsIn = [];
            var windowsOut = [];
            for(var d = 0; d &lt; 4; d ++) {
                windowsIn.push(new BABYLON.Vector3(windowData[3 * d + 12 * p], windowData[3 * d  + 12 * p + 1], windowData[3 * d + 12 * p + 2]));
                windowData[3 * d + 12 * p] += ply * wallNormal.x;
                windowData[3 * d + 12 * p + 2] += ply * wallNormal.z;
                windowsOut.push(new BABYLON.Vector3(windowData[3 * d + 12 * p], windowData[3 * d  + 12 * p + 1], windowData[3 * d + 12 * p + 2]));
            }
            windowCornersIn.push(windowsIn);
            windowCornersOut.push(windowsOut);
        }            
        innerWindowCorners.push(windowCornersIn);            
        outerWindowCorners.push(windowCornersOut);

        //Construct OUTER wall facet positions from inner wall 
        //Add outer wall corner positions back to wallData positions
        wallData.positions = [];

        wallData.positions.push(outerBaseCorners[w].x, outerBaseCorners[w].y, outerBaseCorners[w].z);
        wallData.positions = wallData.positions.concat(doorData);            
        wallData.positions.push(outerBaseCorners[w + 1].x, outerBaseCorners[w + 1].y, outerBaseCorners[(w + 1) % nbWalls].z);
        wallData.positions.push(outerTopCorners[w + 1].x, outerTopCorners[w + 1].y, outerTopCorners[(w + 1) % nbWalls].z);
        wallData.positions.push(outerTopCorners[w].x, outerTopCorners[w].y, outerTopCorners[w].z);
        wallData.positions = wallData.positions.concat(windowData);

        //Calulate exterior wall uvs
        polygonTriangulation._points.elements.forEach(function (p)  {
            if (p.x == 0) {
                uvx = exteriorUV.x;
            }
            else if (wallLength - p.x &lt; 0.000001) {
                uvx = exteriorUV.x + (wallDiff + p.x) * (exteriorUV.z - exteriorUV.x) / (maxL + wallDiff)
            }
            else {
                uvx = exteriorUV.x + (0.5 * wallDiff + p.x) * (exteriorUV.z - exteriorUV.x) / (maxL + wallDiff);
            }
            uvy = exteriorUV.y + p.y * (exteriorUV.w - exteriorUV.y) / height;
            uvs.push(uvx, uvy);                    
        });

        nbIndices = positions.length/3; // current number of indices

        //Add outer wall positions, uvs and colors (repeated for flat shaded mesh)
        positions = positions.concat(wallData.positions);


        //Reverse indices for correct normals
        wallData.indices.reverse();

        indices = indices.concat(wallData.indices.map(function(idx){
            return idx + nbIndices;
        }));

        //Construct facets for base and door top and door sides, repeating positions for flatshaded mesh
        var doorsRemaining = doors;
        var doorNb = 0;

        if (doorsRemaining &gt; 0) {
            //base
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerBaseCorners[w].x, innerBaseCorners[w].y, innerBaseCorners[w].z); //tl
            positions.push(outerBaseCorners[w].x, outerBaseCorners[w].y, outerBaseCorners[w].z); //bl
            positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //tr
            positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //br

            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left                
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].left/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].left/maxL, exteriorUV.y); //base right

            indices.push(nbIndices, nbIndices + 2, nbIndices + 3, nbIndices + 3, nbIndices + 1, nbIndices);

            //left side
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //br
            positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //tr
            positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //bl
            positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl

            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top right
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top Left

            indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices, nbIndices + 3, nbIndices + 2);

            //top
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //bl
            positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //br
            positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl
            positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr

            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right

            indices.push(nbIndices + 2, nbIndices + 1, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1);

            //right side
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //tl
            positions.push(innerDoorCorners[w][doorNb][3].x, innerDoorCorners[w][doorNb][3].y, innerDoorCorners[w][doorNb][3].z); //bl
            positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr
            positions.push(outerDoorCorners[w][doorNb][3].x, outerDoorCorners[w][doorNb][3].y, outerDoorCorners[w][doorNb][3].z); //br

            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top Left
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y); //base right

            indices.push(nbIndices, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1, nbIndices + 3);
        }
        doorsRemaining--
        doorNb++

        while (doorsRemaining &gt; 0 ) {

            //base
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb - 1][3].x, innerDoorCorners[w][doorNb - 1][3].y, innerDoorCorners[w][doorNb -1][3].z); //bl
            positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //br
            positions.push(outerDoorCorners[w][doorNb - 1][3].x, outerDoorCorners[w][doorNb - 1][3].y, outerDoorCorners[w][doorNb - 1][3].z); //tl
            positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //tr

            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (walls[w].doorSpaces[doorNb].left - (walls[w].doorSpaces[doorNb - 1].left + walls[w].doorSpaces[doorNb - 1].door.width))/maxL/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (walls[w].doorSpaces[doorNb].left - (walls[w].doorSpaces[doorNb - 1].left + walls[w].doorSpaces[doorNb - 1].door.width))/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right

            indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices + 3, nbIndices + 2, nbIndices);

            //left side
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb][0].x, innerDoorCorners[w][doorNb][0].y, innerDoorCorners[w][doorNb][0].z); //br
            positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //tr
            positions.push(outerDoorCorners[w][doorNb][0].x, outerDoorCorners[w][doorNb][0].y, outerDoorCorners[w][doorNb][0].z); //bl
            positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl

            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top right
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top Left

            indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices, nbIndices + 3, nbIndices + 2);

            //top
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb][1].x, innerDoorCorners[w][doorNb][1].y, innerDoorCorners[w][doorNb][1].z); //bl
            positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //br
            positions.push(outerDoorCorners[w][doorNb][1].x, outerDoorCorners[w][doorNb][1].y, outerDoorCorners[w][doorNb][1].z); //tl
            positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr

            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].doorSpaces[doorNb].door.width/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right

            indices.push(nbIndices + 2, nbIndices + 1, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1);

            //right side
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerDoorCorners[w][doorNb][2].x, innerDoorCorners[w][doorNb][2].y, innerDoorCorners[w][doorNb][2].z); //tl
            positions.push(innerDoorCorners[w][doorNb][3].x, innerDoorCorners[w][doorNb][3].y, innerDoorCorners[w][doorNb][3].z); //bl
            positions.push(outerDoorCorners[w][doorNb][2].x, outerDoorCorners[w][doorNb][2].y, outerDoorCorners[w][doorNb][2].z); //tr
            positions.push(outerDoorCorners[w][doorNb][3].x, outerDoorCorners[w][doorNb][3].y, outerDoorCorners[w][doorNb][3].z); //br

            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top Left
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].doorSpaces[doorNb].door.height/maxH); //top right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y); //base right

            indices.push(nbIndices, nbIndices + 3, nbIndices + 2, nbIndices, nbIndices + 1, nbIndices + 3);

            doorsRemaining--
            doorNb++

        } 

        doorNb--;
        nbIndices = positions.length/3; // current number of indices

        //final base
        if(doors &gt; 0) {
            positions.push(innerDoorCorners[w][doorNb][3].x, innerDoorCorners[w][doorNb][3].y, innerDoorCorners[w][doorNb][3].z); //bl
            positions.push(innerBaseCorners[w + 1].x, innerBaseCorners[w + 1].y, innerBaseCorners[w + 1].z); //br
            positions.push(outerDoorCorners[w][doorNb][3].x, outerDoorCorners[w][doorNb][3].y, outerDoorCorners[w][doorNb][3].z); //tl
            positions.push(outerBaseCorners[w + 1].x, outerBaseCorners[w + 1].y, outerBaseCorners[w + 1].z); //tr

            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (wallLength - (walls[w].doorSpaces[doorNb].left + walls[w].doorSpaces[doorNb].door.width))/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * (wallLength - (walls[w].doorSpaces[doorNb].left + walls[w].doorSpaces[doorNb].door.width))/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right

        }
        else {
            positions.push(innerBaseCorners[w].x, innerBaseCorners[w].y, innerBaseCorners[w].z); //bl
            positions.push(innerBaseCorners[w + 1].x, innerBaseCorners[w + 1].y, innerBaseCorners[w + 1].z); //br
            positions.push(outerBaseCorners[w].x, outerBaseCorners[w].y, outerBaseCorners[w].z); //tl
            positions.push(outerBaseCorners[w + 1].x, outerBaseCorners[w + 1].y, outerBaseCorners[w + 1].z); //tr

            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * wallLength/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * wallLength/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right

        }
        indices.push(nbIndices, nbIndices + 1, nbIndices + 3, nbIndices + 3, nbIndices + 2, nbIndices);

        //Construct facets for window base, top and sides, repeating positions for flatshaded mesh
        for (ww = 0 ; ww &lt; innerWindowCorners[w].length; ww++) {
            //left side
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerWindowCorners[w][ww][3].x, innerWindowCorners[w][ww][3].y, innerWindowCorners[w][ww][3].z); //tr
            positions.push(innerWindowCorners[w][ww][0].x, innerWindowCorners[w][ww][0].y, innerWindowCorners[w][ww][0].z); //br
            positions.push(outerWindowCorners[w][ww][3].x, outerWindowCorners[w][ww][3].y, outerWindowCorners[w][ww][3].z); //tl
            positions.push(outerWindowCorners[w][ww][0].x, outerWindowCorners[w][ww][0].y, outerWindowCorners[w][ww][0].z); //bl

            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height/maxH); //top right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height/maxH); //top Left
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left

            indices.push(nbIndices + 1, nbIndices, nbIndices + 3,  nbIndices + 2, nbIndices + 3, nbIndices);

            //base
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerWindowCorners[w][ww][0].x, innerWindowCorners[w][ww][0].y, innerWindowCorners[w][ww][0].z); //tl
            positions.push(innerWindowCorners[w][ww][1].x, innerWindowCorners[w][ww][1].y, innerWindowCorners[w][ww][1].z); //tr
            positions.push(outerWindowCorners[w][ww][0].x, outerWindowCorners[w][ww][0].y, outerWindowCorners[w][ww][0].z); //bl
            positions.push(outerWindowCorners[w][ww][1].x, outerWindowCorners[w][ww][1].y, outerWindowCorners[w][ww][1].z); //br

            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width/maxL, exteriorUV.y); //base right

            indices.push(nbIndices + 1, nbIndices, nbIndices + 3, nbIndices + 3,nbIndices, nbIndices + 2);

            //right side
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerWindowCorners[w][ww][1].x, innerWindowCorners[w][ww][1].y, innerWindowCorners[w][ww][1].z); //bl
            positions.push(innerWindowCorners[w][ww][2].x, innerWindowCorners[w][ww][2].y, innerWindowCorners[w][ww][2].z); //tl
            positions.push(outerWindowCorners[w][ww][1].x, outerWindowCorners[w][ww][1].y, outerWindowCorners[w][ww][1].z); //br
            positions.push(outerWindowCorners[w][ww][2].x, outerWindowCorners[w][ww][2].y, outerWindowCorners[w][ww][2].z); //tr

            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height/maxH); //top Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x), exteriorUV.y + (exteriorUV.w - exteriorUV.y) * walls[w].windowSpaces[ww].window.height/maxH); //top right

            indices.push(nbIndices + 1, nbIndices + 2, nbIndices + 3, nbIndices, nbIndices + 2, nbIndices + 1);

            //top
            nbIndices = positions.length/3; // current number of indices

            positions.push(innerWindowCorners[w][ww][2].x, innerWindowCorners[w][ww][2].y, innerWindowCorners[w][ww][2].z); //br
            positions.push(innerWindowCorners[w][ww][3].x, innerWindowCorners[w][ww][3].y, innerWindowCorners[w][ww][3].z); //bl
            positions.push(outerWindowCorners[w][ww][2].x, outerWindowCorners[w][ww][2].y, outerWindowCorners[w][ww][2].z); //tr
            positions.push(outerWindowCorners[w][ww][3].x, outerWindowCorners[w][ww][3].y, outerWindowCorners[w][ww][3].z); //tl

            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width/maxL, exteriorUV.y); //base right
            uvs.push(exteriorUV.x, exteriorUV.y); //base Left
            uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * walls[w].windowSpaces[ww].window.width/maxL, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right
            uvs.push(exteriorUV.x , exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left

            indices.push(nbIndices + 3, nbIndices, nbIndices + 2, nbIndices + 1, nbIndices, nbIndices + 3);

        }

        //Construction of top of wall facets
        nbIndices = positions.length/3; // current number of indices

        positions.push(innerTopCorners[w].x, innerTopCorners[w].y, innerTopCorners[w].z); //tl
        positions.push(innerTopCorners[w + 1].x, innerTopCorners[w + 1].y, innerTopCorners[w + 1].z); //tr
        positions.push(outerTopCorners[w].x, outerTopCorners[w].y, outerTopCorners[w].z); //bl
        positions.push(outerTopCorners[w + 1].x, outerTopCorners[w + 1].y, outerTopCorners[w + 1].z); //br

        uvx = exteriorUV.x + 0.5 * wallDiff * (exteriorUV.z - exteriorUV.x)/maxL;
        uvs.push(uvx, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top Left

        uvx = exteriorUV.x + (0.5 * wallDiff + wallLength) * (exteriorUV.z - exteriorUV.x)/maxL;
        uvs.push(uvx, exteriorUV.y + (exteriorUV.w - exteriorUV.y) * ply/maxH); //top right

        uvs.push(exteriorUV.x, exteriorUV.y); //base Left        
        uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * exteriorWallLength/(maxL + wallDiff), exteriorUV.y); //base right

        indices.push(nbIndices + 1, nbIndices, nbIndices + 3, nbIndices + 2, nbIndices + 3, nbIndices); 

        for(var p = interiorIndex; p &lt; positions.length/3; p++) {
            colors.push(exteriorColor.r, exteriorColor.g, exteriorColor.b, exteriorColor.a);
        }

        if (interior) {  //close ends of walls
                nbIndices = positions.length/3; // current number of indices

                positions.push(innerBaseCorners[0].x, innerBaseCorners[0].y, innerBaseCorners[0].z);
                positions.push(outerBaseCorners[0].x, outerBaseCorners[0].y, outerBaseCorners[0].z);
                positions.push(outerTopCorners[0].x, outerTopCorners[0].y, outerTopCorners[0].z);
                positions.push(innerTopCorners[0].x, innerTopCorners[0].y, innerTopCorners[0].z);

                uvs.push(exteriorUV.x, exteriorUV.y);
                uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y);
                uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.z);
                uvs.push(exteriorUV.x, exteriorUV.z);

                indices.push(nbIndices, nbIndices + 1, nbIndices + 2, nbIndices, nbIndices + 2, nbIndices + 3);

                nbIndices = positions.length/3; // current number of indices

                positions.push(innerBaseCorners[nbWalls -1].x, innerBaseCorners[nbWalls -1].y, innerBaseCorners[nbWalls -1].z);
                positions.push(outerBaseCorners[nbWalls -1].x, outerBaseCorners[nbWalls -1].y, outerBaseCorners[nbWalls -1].z);
                positions.push(outerTopCorners[nbWalls -1].x, outerTopCorners[nbWalls -1].y, outerTopCorners[nbWalls -1].z);
                positions.push(innerTopCorners[nbWalls -1].x, innerTopCorners[nbWalls -1].y, innerTopCorners[nbWalls -1].z);

                uvs.push(exteriorUV.x, exteriorUV.y);
                uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.y);
                uvs.push(exteriorUV.x + (exteriorUV.z - exteriorUV.x) * ply / maxL, exteriorUV.z);
                uvs.push(exteriorUV.x, exteriorUV.z);

                indices.push(nbIndices + 1, nbIndices, nbIndices + 2, nbIndices + 2, nbIndices, nbIndices + 3);

                for(var p = 0; p &lt; 8; p++) {
                    colors.push(exteriorColor.r, exteriorColor.g, exteriorColor.b, exteriorColor.a);
                }
            }

        var compareLeft = function(a, b) {
            return a.left - b.left
        }

    }

    var normals = [];

    BABYLON.VertexData.ComputeNormals(positions, indices, normals);
    BABYLON.VertexData._ComputeSides(BABYLON.Mesh.FRONTSIDE, positions, indices, normals, uvs);


    //Create a custom mesh  
    var customMesh = new BABYLON.Mesh(&quot;custom&quot;, scene);

    //Create a vertexData object
    var vertexData = new BABYLON.VertexData();

    //Assign positions and indices to vertexData
    vertexData.positions = positions;
    vertexData.indices = indices;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    vertexData.colors = colors;

    //Apply vertexData to custom mesh
    vertexData.applyToMesh(customMesh);

    return customMesh;

}
</code></pre>
<h3><a name="polygonmeshbuilder-wallbuilder-method" class="anchor" href="#polygonmeshbuilder-wallbuilder-method"></a>PolygonMeshBuilder wallBuilder Method</h3><p>This code should be copied and pasted within your own code.</p>
<pre><code class="lang-javascript">BABYLON.PolygonMeshBuilder.prototype.wallBuilder = function (w0, w1) {
    var positions = [];
    var iuvs = [];
    var euvs = [];
    var icolors = [];
    var ecolors = [];
    var direction = w1.corner.subtract(w0.corner).normalize();
    var angle = Math.acos(direction.x);
    if(direction.z !=0) {
        angle *= direction.z/Math.abs(direction.z);
    }    
    this._points.elements.forEach(function (p) {
        positions.push(p.x * Math.cos(angle) + w0.corner.x, p.y, p.x * Math.sin(angle) + w0.corner.z);
    });
    var indices = [];        
    var res = earcut(this._epoints, this._eholes, 2);
    for (var i = res.length; i &gt; 0; i--) {
        indices.push(res[i - 1]);
    };            
    return {positions: positions, indices: indices};
};
</code></pre>
<h3><a name="building-the-data-and-parameters-an-example" class="anchor" href="#building-the-data-and-parameters-an-example"></a>Building the Data and Parameters, an example</h3><pre><code class="lang-javascript">    var baseData = [-3, -2, -1, -4, 1,-4, 3, -2, 5, -2, 5, 1, 2, 1, 2, 3, -3, 3];


    var corners = [];
    for(b = 0; b &lt; baseData.length/2; b++) {
        corners.push(new corner(baseData[2*b], baseData[2*b + 1]));
    }


    var door = new door(1, 1.8);
    var doorSpace = new doorSpace(door, 1);

    var window0 = new window(1.2, 2.4);
    var window1 = new window(2, 2.4);

    var windowSpace02 = new windowSpace(window0, 0.814, 0.4);
    var windowSpace1 =  new windowSpace(window0, 0.4, 0.4);
    var windowSpace78 = new windowSpace(window1, 1.5, 0.4);

    var walls = [];
    for(c=0; c&lt;corners.length; c++) {
        walls.push(new wall(corners[c]));
    }

    walls[0].windowSpaces = [windowSpace02];
    walls[1].windowSpaces = [windowSpace1];
    walls[2].windowSpaces = [windowSpace02];
    walls[7].windowSpaces = [windowSpace78];
    walls[8].windowSpaces = [windowSpace78];

    walls[5].doorSpaces = [doorSpace];


    var ply = 0.3;
    var height = 3.2;
</code></pre>
<h3><a name="build-interior-walls" class="anchor" href="#build-interior-walls"></a>Build Interior Walls</h3><p>Really this is a method of building walls that do not form an enclosing shell, i.e. the first and last corners do not produce a wall between them.</p>
<p>Add the option interior: true, for example </p>
<pre><code class="lang-javascript">var wall = buildFromPlan(walls, ply, height, {interior:true}, scene);
</code></pre>
<p>You can add doors and windows (?hatches) to these walls as well.</p>
<h2><a name="playground-examples" class="anchor" href="#playground-examples"></a>Playground Examples</h2><ul>
<li><a href="https://www.babylonjs-playground.com/#4GBWI5#265">Playground Example of a House Built from a FloorPlan</a> - <i class="fa fa-eye" onclick="createIframe('4GBWI5#265', this)"></i><div class="iframeContainer"></div></li>
<li><a href="https://www.babylonjs-playground.com/#1Z71FW#103">Playground Example of None Enclosing Wall</a> - <i class="fa fa-eye" onclick="createIframe('1Z71FW#103', this)"></i><div class="iframeContainer"></div></li>
<li><a href="https://www.babylonjs-playground.com/#1Z71FW#102">Playground Example of None Enclosing Wall with UVs</a> - <i class="fa fa-eye" onclick="createIframe('1Z71FW#102', this)"></i><div class="iframeContainer"></div></li>
<li><a href="https://www.babylonjs-playground.com/#1Z71FW#45">Playground Example of House and Interior Walls</a> - <i class="fa fa-eye" onclick="createIframe('1Z71FW#45', this)"></i><div class="iframeContainer"></div></li>
</ul>
<h1><a name="further-reading" class="anchor" href="#further-reading"></a>Further Reading</h1><p><a href="/samples/House">Developing the Code for Build From Plans</a><br><a href="/samples/roof">Adding a Roof</a></p>
<h2><a name="level-1" class="anchor" href="#level-1"></a>Level 1</h2><p><a href="/how_to/parametric_shapes#extruded-non-regular-polygon">Extruded Non Regular Polygon</a>  </p>
<h2><a name="level-2" class="anchor" href="#level-2"></a>Level 2</h2><p><a href="/How_To/PolygonMeshBuilder">Polygon Mesh Builder</a></p>
</div></div></div><footer class="footer"><div class="footer-item"><a href="https://www.babylonjs.com" target="_blank"><i class="fa fa-home"></i>    Babylonjs.com</a></div><div class="footer-item"><a href="https://forum.babylonjs.com" target="_blank"><i class="fa fa-html5"></i>    Forum</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Babylon.js" target="_blank"><i class="fa fa-github"></i>    Github</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Documentation" target="_blank"><i class="fa fa-code-fork"></i>    Contribute </a></div><div class="footer-item"><a href="https://www.netlify.com" target="_blank"><i class="fa fa-heart"></i> Deployed by netlify            </a></div></footer><script src="/js/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/0.1.9/slideout.min.js"></script><script src="/js/index.js"></script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-41767310-3', 'auto');
ga('send', 'pageview');</script><!-- HIGHLIGHT JS--><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/javascript.min.js"></script><script src="/js/static.js"></script><script>$('code').each(function(){
    $(this).text($(this).text().replace(/&nbsp;/gi, ''));
});
hljs.initHighlightingOnLoad();</script></body></html>