<!DOCTYPE html><html style="height:100%;"><head lang="en"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="wcRjktXhF6DAjmhneKS7UatweBIkEF6QfqsNhAYbUgg"><title>Understanding how normal maps work - Babylon.js Documentation</title><link rel="shortcut icon" href ="/public/html/img/favicon.ico"><meta name="msapplication-TileColor" content="#ffffff"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="https://use.typekit.net/cta4xsb.css"><link rel="stylesheet" href ="/public/html//cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" href ="/public/html/css/libs/slideout.css"><link rel="stylesheet" href ="/public/html/css/libs/highlight/github.css"><link rel="stylesheet" href ="/public/html//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"><link rel="stylesheet" href ="/public/html//cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.3/css/perfect-scrollbar.min.css"><link rel="stylesheet" href ="/public/html/css/main.css"><link rel="stylesheet" href ="/public/html//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/styles/default.min.css"></head><body><nav id="menu"></nav><nav class="nav-main" style="position:inherit;"><!-- Hamburger menu : displayed only in small screens--><i class="fa fa-bars" id="mobilemenu"></i><div class="banner"><div class="menu"><div class="do-not-hover" id="home"><a href ="/public/html/">HOME</a></div><div class="item" id="whatsnew"><a href ="/public/html/whats-new">What's new</a></div><div class="item" id="feature"><a href ="/public/html/babylon101">Babylon 101      </a></div><div class="item" id="feature"><a href ="/public/html/examples">Examples                        </a></div><div class="item active" id="How_To"><a href ="/public/html/How_To">How To...</a></div><div class="item" id="feature"><a href ="/public/html/features">Features</a></div><div class="item" id="resources"><a href ="/public/html/resources">Resources</a></div><div class="item" id="extensions"><a href ="/public/html/extensions">Extensions</a></div><div class="item" id="samples"><a href ="/public/html/snippets">Snippets        </a></div><div class="item" id="classes"><a href ="/public/html/api">API</a></div><div class="item" id="playground"><a href ="/public/html/playground">Playground</a></div></div><div class="more"><div class="searchbar"><form method="get" action="/search"><input type="text" name="bjsq" placeholder="Search..."><button type="submit"><i class="fa fa-search"></i></button></form></div></div></div></nav><div id="wrapper"><div class="statics-banner"><div class="img-holder details"><a href ="/public/html/"><img src="/img/babylonjs_identity_color_dark.svg"></a><a href ="/public/html/How_To"><h1>How To</h1></a><div></div></div></div><div class="horizontal-separator"></div><div class="static-content"><h1>Understanding how normal maps work</h1><br><div id="staticContent"><p>The goal of this article is to clearly explain what is happening with normal textures with some samples to hopefully clear up any confusion about what is happening.</p>
<p>To do so we are going to use this playground as an example: <a href="https://playground.babylonjs.com/#YCCU8U">https://playground.babylonjs.com/#YCCU8U</a> - <i class="fa fa-eye" onclick="createIframe('YCCU8U#', this)"></i><div class="iframeContainer"></div></p>
<p>What the normal map formats are and what they look like?</p>
<ul>
<li>OpenGL expects the first pixel in the texture to be at the bottom (lower-left pixel) and can be thought of as bottom up</li>
<li>DirectX expects the first pixel in the texture to be at the top (upper-left pixel) and can be thought of as top down</li>
</ul>
<p>To see what that looks like, we can consider this normal map comparison:</p>
<p><img src="/img/how_to/Materials/normal_maps1.jpg" alt="Different normal maps convention"></p>
<p>To help identify what normal format you have by looking at the texture, you need to understand if details on the texture are embossed (stands proud of the surface) or debossed (does not stand proud of the surface). As an example, the left shapes in each texture above are embossed and the right shapes in each are debossed. Next look at the tones in the map and assume that the lighter tones in the normal texture (the light greens) are being cast from a light either directly above or below the texture. If you know your details are embossed and the lightest tones are at the top suggesting the light is positioned above your texture, you have an OpenGL format texture. If the lightest tones on an embossed detail are on the bottom, suggesting the light is below the texture, you have a DirectX format texture.</p>
<p>Truly, the only difference between the two formats at the file level is that the Y coordinate is inverted, positive being up in OpenGL and down in DirectX. If you assume the R, G, and B channels map to the coordinate system X, Y, and Z, you can see that we only need to change the G channel of the texture to convert between the formats. And the only operation you need to do is an invert of the tones in the G channel if you want to convert in an image editing package. Or you could convert directly in the shader by including a one minus pixel color for the G channel of the texture. And in our Node Material Editor, we have parameters on the perturb normal node that allow you to invert Y in the normal texture to effectively convert between the two formats.</p>
<p>Now let’s look at the requirements used by software:</p>
<ul>
<li><a href="https://academy.substance3d.com/courses/Substance-guide-to-Rendering-in-Arnold">Arnold Renderer uses OpenGL format</a></li>
<li><a href="https://knowledge.autodesk.com/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/ENU/Maya-Customizing/files/GUID-BF017019-B89A-47F0-8AB5-106C058AB854-htm.html">Maya can use either format but needs to be specified in the Display preferences</a>. I believe that the default is OpenGL - Core Profile (Compatibility) due to Arnold now being their bundled renderer.</li>
</ul>
<p><img src="/img/how_to/Materials/normal_maps2.png" alt="Maya export window"></p>
<p>When you are creating your textures, you can specify the format for the normal map before baking, but you need to align with your final use case. With that in mind, whether you are targeting an offline rendering engine like Arnold or a real-time rendering engine like Babylon.js, you need to know which format is expected by the renderer’s shaders and how your file formats may impact that choice. So let’s look at those:</p>
<ul>
<li><a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materialnormaltexture">glTF uses OpenGL as the format for its normal textures</a>.</li>
<li>Babylon.js uses DirectX as the format for its normal textures for Standard Materials, PBR materials, and Node Materials</li>
</ul>
<p>This would seem to be a simple conversion from OpenGL to DirectX formats when using a glTF, but there is another issue that complicates this matter.</p>
<ul>
<li>glTF uses a right-handed coordinate system</li>
<li>Babylon.js uses a left-handed coordinate system</li>
</ul>
<p>This is important for this reason:</p>
<p><img src="/img/how_to/Materials/normal_maps3.jpg" alt="Visual difference between conventions"></p>
<p>This is a glTF file with two planes in it exported from Maya. They were both assigned an Arnold standard surface shader with an OpenGL format normal map. When the file is loaded the plane on the right has its material replaced</p>
<p>When you load that glTF into Babylon.js, we take care of converting the file to match the handedness of the scene for you. However, what you see here is that the plane on the right has been assigned a Node Material with a DirectX format normal texture. It may be a little confusing why the normal looks incorrect when we just said that Babylon materials expect a DirectX format normal but this has to do with how the glTF was loaded. Babylon.js materials still expect a DirectX format normal, but when we loaded the glTF, we inverted the tangent space in Y so that it conforms with the OpenGL convention of glTF. That means that any normal texture that is applied to the mesh, no matter if it is a material from the original file or one that is created in Babylon.js needs to be authored in the OpenGL format to render correctly.</p>
<p>Now it may be easy to assume that if I just save my files in the .babylon format that all would be fixed and I could just save all my normal maps and DirectX format. You would be correct only if you do not change any textures in the materials assigned to your meshes and just used the assets from the .babylon file directly. If you assign a new texture to a material on a mesh from a .babylon file or you assign an entirely new material such as a node material you will get an unexpected result. The image below shows a .babylon file imported with the same OpenGL format normal from above on the left and on the right a node material that assigns a DirectX format normal to the plane.</p>
<p><img src="/img/how_to/Materials/normal_maps4.jpg" alt="Normal direction based on conventions"></p>
<p>So what happened? The plane on the left looks incorrect as it should, but the one on the right looks completely wrong. This stems from the origin of Babylon.js as it was a spiritual successor to an older engine that Deltakosh wrote which was a DirectX engine. Much the same as mentioned before, DirectX formatted normal textures are read from the upper left pixel rather than the lower left pixel in OpenGL, UV space in DirectX is also read from the upper left instead of the lower left.</p>
<p>To illustrate this, here is a simple graph to show how the UVs are stored in a glTF file versus .babylon file:</p>
<p><img src="/img/how_to/Materials/normal_maps5.png" alt="UV directions"></p>
<p>When we export a .babylon file, we don’t change anything about the texture files as that could cause some extra problems when updating or editing the textures, but we know on load that the UV space is DirectX with the textures likely being in OpenGL format. So when we read in the textures we store them in memory inverted in Y. You can see this if you inspect a texture in your scene loaded from a .babylon file. You will notice an indication as to whether it is &quot;Stored as Inverted on Y&quot; in the list of general properties.</p>
<p><img src="/img/how_to/Materials/normal_maps6.jpg" alt="Inspector"></p>
<p>So how do we fix this. There are three ways we can work around this issue when adding new textures to a loaded .babylon file, one art fix and two code fixes. The art fix would be to author your normal textures in DirectX format and save your textures inverted in Y. You could do this on export from your texturing tool like Substance or you could manually invert them in Y in an image editor. This could be very disruptive to your art pipeline, so it may not be the right solve.</p>
<p>The code fixes are simpler. One is to invert your texture when you load it by using the <a href="https://doc.babylonjs.com/api/classes/babylon.texture#constructor">invertY parameter available in BABYLON.Texture</a> which is the easiest solve. However, if you are loading textures through Node Material rather than in your javascript, that won’t work. This leads us to the other code solve which is to add a one minus Y operation to the UVs fed to your texture as you can see below.</p>
<p><img src="/img/how_to/Materials/normal_maps7.png" alt="Node material"></p>
<p>This will correct your texture inversion issue and as you can see this will fix the rendering. Again, the planes are loaded from a .babylon file and the left one was assigned an OpenGL format normal texture in Maya and the right uses a DirectX format normal assigned with a Node Material that has the UV space inverted in Y.</p>
<p><img src="/img/how_to/Materials/normal_maps9.jpg" alt="Final result"></p>
<p>It is a deep topic which is made more complex by multiple file formats with their own conventions, but there are tools available in engine to switch to whatever you need. In a way we can say that while Babylon.js was originally designed based on DirectX principles, it has since become more convention agnostic as there are plenty of tools available to make your assets work correctly so long as you know where you are coming from and where you are going.</p>
</div></div></div><footer class="footer"><div class="footer-item"><a href="https://www.babylonjs.com" target="_blank"><i class="fa fa-home"></i>    Babylonjs.com</a></div><div class="footer-item"><a href="https://forum.babylonjs.com" target="_blank"><i class="fa fa-html5"></i>    Forum</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Babylon.js" target="_blank"><i class="fa fa-github"></i>    Github</a></div><div class="footer-item"><a href="https://github.com/BabylonJS/Documentation" target="_blank"><i class="fa fa-code-fork"></i>    Contribute </a></div><div class="footer-item"><a href="https://www.netlify.com" target="_blank"><i class="fa fa-heart"></i> Deployed by netlify            </a></div></footer><script src="/js/jquery.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/0.1.9/slideout.min.js"></script><script src="/js/index.js"></script><script>(function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
ga('create', 'UA-41767310-3', 'auto');
ga('send', 'pageview');</script><!-- HIGHLIGHT JS--><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/javascript.min.js"></script><script src="/js/static.js"></script><script>$('code').each(function(){
    $(this).text($(this).text().replace(/&nbsp;/gi, ''));
});
hljs.initHighlightingOnLoad();</script></body></html>